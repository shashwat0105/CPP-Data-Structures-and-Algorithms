// "THOSE WHO CANNOT REMEMBER THE PAST ARE CONDEMNED TO REPEAT IT" ~ DP

// High package companies ask this topic
// Nutanix asked a derivative of MCM(matrix chain multiplication) ques
// DP = Enhanced recursion(recursion + storage)
// How to identify a dynamic programming problem?
1. Choice - whether to select an object or not -> recursion hai, 
            Then if the recursion is calling one function it is not DP, if it is calling 2 function then yes, it can be DP
2. Optimality - Max, Min, Largest etc

// DONT MAKE TABLE IN THE START ONLY(WHICH IS CALLED TOP DOWN APPROACH) :- WRONG APPROACH(COZ U WILL DEFINITELY MAKE A MISTAKE IN MAKING IT)
Steps to solve:-
Recursive -> Memoize -> Top down(if u want)
Just write the recursive function first.


Knapsack Problem are of 3 types
1. Fractional Knapsack - Ques of Greedy(No use of DP)
2. 0-1 Knapsack (Use of DP)
3. Unbounded Knapsack (In this u can put any item any number of times too ie unbounded supply of items) In other u can put only once

// Nice Article: 
// https://www.hackerearth.com/practice/algorithms/dynamic-programming/introduction-to-dynamic-programming-1/tutorial/


First, design the backtrack function, which returns the correct answer. Pass whatever arguments you need to this function.(simple recursive function)
Second, remove all the arguments from the function, that are either read-only or redundant (you are able to compute them from other arguments). Known as Minimizing the state space of function arguments
And third, simply cache it. (memoisation) [This step changes the TC from 2^n to n^2]

// Learnings:
// Sometimes when the t[n] is filled with the help of t[n] say t[n]+=jump(n-i,k,t) in this case you can't initialize all elements of t[n] to -1, instead initialize to 0.

// If you dont have access to main function(for memset) this way u can make a 2D array and initialise it to -1
// vector<vector<int>>dp(n + 1, vector<int>(sum + 1, -1));
// can initialise it in other function as well.

// In knapsacks(0/1 or unbounded) the topmost and left most are initialise both with all 0 so do it in double for loop together

// But in in their variations like subset sum or rod cutting or any other I do it by seperate for loops(no relation with i or j) coz different values are to be initialised.

